{% if namespace %}
package {{ namespace|lower }}
{% endif %}

import (
    "encoding/json"
    "io/ioutil"
    "net/http"
    "time"
)

type {{ className }} struct {
    BaseUrl string
    Token string
{% for name, arg in properties %}
    {{ name|capitalize }} {{ arg.type }}
{% endfor %}
}

{% for methodName, method in methods %}
// {{ methodName|capitalize }} {{ method.description }}
func (r {{ className }}) {{ methodName|capitalize }}({% for name, arg in method.args %}{{ name }} {{ arg.type }}{% if not loop.last %}, {% endif %}{% endfor %}) {{ method.return.type }} {

{% if method.httpMethod != "GET" and method.httpMethod != "DELETE" %}
    raw, err := json.Marshal(data)
    if err != nil {
        panic(err)
    }
    var reqBody = bytes.NewReader(raw)
{% endif %}

    req, err := http.NewRequest("{{ method.httpMethod }}", r.BaseURL + url, {% if method.httpMethod != "GET" and method.httpMethod != "DELETE" %}reqBody{% else %}nil{% endif %})
{% if method.httpMethod != "GET" and method.httpMethod != "DELETE" %}
    req.Header.Set("Content-Type", "application/json")
{% endif %}
{% if method.secure %}
    req.Header.Set("Authorization", "Bearer " + r.Token)
{% endif %}

    client := &http.Client{}
    resp, err := client.Do(req)

    if err != nil {
        panic(err)
    }

    defer resp.Body.Close()
    respBody, _ := ioutil.ReadAll(resp.Body)

    var response {{ method.return.type }}
    json.Unmarshal(respBody, &response)

    return response
}

{% endfor %}

func New{{ className }}({% for name, arg in properties %}{{ name }} {{ arg.type }}, {% endfor %}baseUrl string, token string) {{ className }} {
    r := {{ className }} {
        BaseUrl: baseUrl + "{% for part in urlParts %}/{% if part.type == 'variable' %}"+{{ part.value }}+"{% else %}{{ part.value }}{% endif %}{{ url|raw }}{% endfor %}",
        Token: token
    }
    return r
}
